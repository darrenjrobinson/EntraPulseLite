"use strict";exports.id=855,exports.ids=[855],exports.modules={4855:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MicrosoftDocsMCPClient: () => (/* binding */ MicrosoftDocsMCPClient)\n});\n\n;// ./src/mcp/clients/HttpStreamableMCPClient.ts\nclass HttpStreamableMCPClient {\n    constructor(serverConfig, authService) {\n        this.sessionId = null;\n        this.requestId = 1;\n        this.serverConfig = serverConfig;\n        this.authService = authService;\n        this.baseUrl = serverConfig.url || 'https://learn.microsoft.com/api/mcp';\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        try {\n            const initRequest = {\n                jsonrpc: '2.0',\n                id: this.getNextId(),\n                method: 'initialize',\n                params: {\n                    protocolVersion: '2024-11-05',\n                    capabilities: {\n                        tools: {},\n                        resources: {},\n                        sampling: {}\n                    },\n                    clientInfo: {\n                        name: 'EntraPulseLite',\n                        version: '1.0.0-beta.1'\n                    }\n                }\n            };\n            console.log('üîå Initializing HTTP Streamable MCP client for:', this.baseUrl);\n            const response = await this.sendRequest(initRequest);\n            if (response.error) {\n                throw new Error(`Initialization failed: ${response.error.message}`);\n            }\n            console.log('‚úÖ HTTP Streamable MCP client initialized successfully');\n        }\n        catch (error) {\n            console.error('‚ùå Failed to initialize HTTP Streamable MCP client:', error);\n            throw error;\n        }\n    }\n    /**\n     * List available tools from the MCP server\n     */\n    async listTools() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list tools: ${response.error.message}`);\n        }\n        return response.result?.tools || [];\n    }\n    /**\n     * Call a tool on the MCP server\n     */\n    async callTool(toolName, arguments_) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/call',\n            params: {\n                name: toolName,\n                arguments: arguments_\n            }\n        };\n        console.log(`üîß HTTP Streamable MCP calling tool \"${toolName}\" with args:`, arguments_);\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Tool call failed: ${response.error.message}`);\n        }\n        console.log(`‚úÖ HTTP Streamable MCP tool \"${toolName}\" completed successfully`);\n        return response.result;\n    }\n    /**\n     * List available resources from the MCP server\n     */\n    async listResources() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list resources: ${response.error.message}`);\n        }\n        return response.result?.resources || [];\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/read',\n            params: {\n                uri\n            }\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to read resource: ${response.error.message}`);\n        }\n        return response.result;\n    }\n    /**\n     * Send HTTP Streamable request to the MCP server\n     */\n    async sendRequest(request) {\n        try {\n            const headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json, text/event-stream',\n                'User-Agent': 'MCP-Client/1.0.0-beta.1'\n            };\n            // Add session ID if we have one\n            if (this.sessionId) {\n                headers['Mcp-Session-Id'] = this.sessionId;\n            }\n            // Add authentication headers if needed\n            if (this.serverConfig.authConfig?.type !== 'none') {\n                try {\n                    const authHeaders = await this.authService.getAuthHeaders('microsoft-docs');\n                    Object.assign(headers, authHeaders);\n                }\n                catch (authError) {\n                    console.warn('Failed to get auth headers for Microsoft Docs MCP:', authError);\n                    // Continue without auth headers as Microsoft Docs MCP may not require authentication\n                }\n            }\n            console.log('üåê Sending HTTP Streamable MCP request:', {\n                url: this.baseUrl,\n                method: request.method,\n                id: request.id,\n                hasSessionId: !!this.sessionId,\n                headers: Object.keys(headers),\n                bodyPreview: JSON.stringify(request).substring(0, 200)\n            });\n            const response = await fetch(this.baseUrl, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(request)\n            });\n            // Log response details for debugging\n            console.log('üì° Received response:', {\n                status: response.status,\n                statusText: response.statusText,\n                contentType: response.headers.get('Content-Type'),\n                hasSessionId: !!response.headers.get('Mcp-Session-Id')\n            });\n            // Check for session ID in response headers\n            const responseSessionId = response.headers.get('Mcp-Session-Id');\n            if (responseSessionId && !this.sessionId) {\n                this.sessionId = responseSessionId;\n                console.log('üìù Received session ID from server:', responseSessionId);\n            }\n            if (!response.ok) {\n                // For debugging 406 errors, try to get response body\n                let errorDetails = `HTTP ${response.status}: ${response.statusText}`;\n                try {\n                    const errorBody = await response.text();\n                    if (errorBody) {\n                        errorDetails += ` - Response: ${errorBody}`;\n                        console.log('‚ùå Error response body:', errorBody);\n                    }\n                }\n                catch (e) {\n                    console.log('‚ùå Could not read error response body');\n                }\n                throw new Error(errorDetails);\n            }\n            const contentType = response.headers.get('Content-Type') || '';\n            // Handle SSE stream response\n            if (contentType.includes('text/event-stream')) {\n                console.log('üì° Received SSE stream response, parsing...');\n                return await this.parseSSEResponse(response);\n            }\n            // Handle JSON response\n            const data = await response.json();\n            console.log('üì® Received JSON response:', {\n                hasResult: !!data.result,\n                hasError: !!data.error,\n                id: data.id\n            });\n            return data;\n        }\n        catch (error) {\n            console.error('‚ùå HTTP Streamable MCP request failed:', error);\n            throw new Error(`HTTP Streamable MCP request failed: ${error.message}`);\n        }\n    }\n    /**\n     * Parse Server-Sent Events response\n     */\n    async parseSSEResponse(response) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body for SSE stream');\n        }\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let lastResponse = null;\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || ''; // Keep incomplete line in buffer\n                for (const line of lines) {\n                    if (line.startsWith('data: ')) {\n                        const data = line.slice(6);\n                        if (data === '[DONE]') {\n                            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No response received' } };\n                        }\n                        try {\n                            const jsonData = JSON.parse(data);\n                            if (jsonData.jsonrpc) {\n                                lastResponse = jsonData;\n                            }\n                        }\n                        catch (parseError) {\n                            console.warn('Failed to parse SSE data:', data);\n                        }\n                    }\n                }\n            }\n            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No valid response received' } };\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     * Get next request ID\n     */\n    getNextId() {\n        return this.requestId++;\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        try {\n            await this.listTools();\n            return true;\n        }\n        catch (error) {\n            console.error('HTTP Streamable MCP health check failed:', error);\n            return false;\n        }\n    }\n}\n\n;// ./src/mcp/clients/MicrosoftDocsMCPClient.ts\n\nclass MicrosoftDocsMCPClient {\n    constructor(serverConfig, authService) {\n        this.httpClient = new HttpStreamableMCPClient(serverConfig, authService);\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        return this.httpClient.initialize();\n    }\n    /**\n     * List available tools from Microsoft Docs MCP server\n     */\n    async listTools() {\n        return this.httpClient.listTools();\n    }\n    /**\n     * Call a tool on the Microsoft Docs MCP server\n     */\n    async callTool(toolName, arguments_) {\n        return this.httpClient.callTool(toolName, arguments_);\n    }\n    /**\n     * List available resources from Microsoft Docs MCP server\n     */\n    async listResources() {\n        return this.httpClient.listResources();\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        return this.httpClient.readResource(uri);\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        return this.httpClient.healthCheck();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL3NyYy9tY3AvY2xpZW50cy9IdHRwU3RyZWFtYWJsZU1DUENsaWVudC50cz8wMDA5Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vc3JjL21jcC9jbGllbnRzL01pY3Jvc29mdERvY3NNQ1BDbGllbnQudHM/MDJlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckNvbmZpZywgYXV0aFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IDE7XG4gICAgICAgIHRoaXMuc2VydmVyQ29uZmlnID0gc2VydmVyQ29uZmlnO1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gYXV0aFNlcnZpY2U7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHNlcnZlckNvbmZpZy51cmwgfHwgJ2h0dHBzOi8vbGVhcm4ubWljcm9zb2Z0LmNvbS9hcGkvbWNwJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgTUNQIGNsaWVudCBhbmQgcGVyZm9ybSBoYW5kc2hha2Ugd2l0aCB0aGUgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2luaXRpYWxpemUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbFZlcnNpb246ICcyMDI0LTExLTA1JyxcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmc6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdFbnRyYVB1bHNlTGl0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAtYmV0YS4xJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SMIEluaXRpYWxpemluZyBIVFRQIFN0cmVhbWFibGUgTUNQIGNsaWVudCBmb3I6JywgdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChpbml0UmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluaXRpYWxpemF0aW9uIGZhaWxlZDogJHtyZXNwb25zZS5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBIVFRQIFN0cmVhbWFibGUgTUNQIGNsaWVudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBIVFRQIFN0cmVhbWFibGUgTUNQIGNsaWVudDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGF2YWlsYWJsZSB0b29scyBmcm9tIHRoZSBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRvb2xzKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogdGhpcy5nZXROZXh0SWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3Rvb2xzL2xpc3QnLFxuICAgICAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCB0b29sczogJHtyZXNwb25zZS5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ/LnRvb2xzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgdG9vbCBvbiB0aGUgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxUb29sKHRvb2xOYW1lLCBhcmd1bWVudHNfKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c19cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflKcgSFRUUCBTdHJlYW1hYmxlIE1DUCBjYWxsaW5nIHRvb2wgXCIke3Rvb2xOYW1lfVwiIHdpdGggYXJnczpgLCBhcmd1bWVudHNfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCBjYWxsIGZhaWxlZDogJHtyZXNwb25zZS5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgSFRUUCBTdHJlYW1hYmxlIE1DUCB0b29sIFwiJHt0b29sTmFtZX1cIiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHJlc291cmNlcyBmcm9tIHRoZSBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFJlc291cmNlcygpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0TmV4dElkKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdyZXNvdXJjZXMvbGlzdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHJlc291cmNlczogJHtyZXNwb25zZS5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ/LnJlc291cmNlcyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIHJlc291cmNlXG4gICAgICovXG4gICAgYXN5bmMgcmVhZFJlc291cmNlKHVyaSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogdGhpcy5nZXROZXh0SWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3Jlc291cmNlcy9yZWFkJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHVyaVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCByZXNvdXJjZTogJHtyZXNwb25zZS5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgSFRUUCBTdHJlYW1hYmxlIHJlcXVlc3QgdG8gdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2V2ZW50LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTUNQLUNsaWVudC8xLjAuMC1iZXRhLjEnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIHNlc3Npb24gSUQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ01jcC1TZXNzaW9uLUlkJ10gPSB0aGlzLnNlc3Npb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhdXRoZW50aWNhdGlvbiBoZWFkZXJzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29uZmlnLmF1dGhDb25maWc/LnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5nZXRBdXRoSGVhZGVycygnbWljcm9zb2Z0LWRvY3MnKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBhdXRoSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChhdXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IGF1dGggaGVhZGVycyBmb3IgTWljcm9zb2Z0IERvY3MgTUNQOicsIGF1dGhFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGhvdXQgYXV0aCBoZWFkZXJzIGFzIE1pY3Jvc29mdCBEb2NzIE1DUCBtYXkgbm90IHJlcXVpcmUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+MkCBTZW5kaW5nIEhUVFAgU3RyZWFtYWJsZSBNQ1AgcmVxdWVzdDonLCB7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmJhc2VVcmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgICAgICAgICAgICBoYXNTZXNzaW9uSWQ6ICEhdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmtleXMoaGVhZGVycyksXG4gICAgICAgICAgICAgICAgYm9keVByZXZpZXc6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLnN1YnN0cmluZygwLCAyMDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5iYXNlVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMb2cgcmVzcG9uc2UgZGV0YWlscyBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+ToSBSZWNlaXZlZCByZXNwb25zZTonLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLFxuICAgICAgICAgICAgICAgIGhhc1Nlc3Npb25JZDogISFyZXNwb25zZS5oZWFkZXJzLmdldCgnTWNwLVNlc3Npb24tSWQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igc2Vzc2lvbiBJRCBpbiByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVNlc3Npb25JZCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdNY3AtU2Vzc2lvbi1JZCcpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlU2Vzc2lvbklkICYmICF0aGlzLnNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkID0gcmVzcG9uc2VTZXNzaW9uSWQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk50gUmVjZWl2ZWQgc2Vzc2lvbiBJRCBmcm9tIHNlcnZlcjonLCByZXNwb25zZVNlc3Npb25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGRlYnVnZ2luZyA0MDYgZXJyb3JzLCB0cnkgdG8gZ2V0IHJlc3BvbnNlIGJvZHlcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JEZXRhaWxzID0gYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscyArPSBgIC0gUmVzcG9uc2U6ICR7ZXJyb3JCb2R5fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4p2MIEVycm9yIHJlc3BvbnNlIGJvZHk6JywgZXJyb3JCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4p2MIENvdWxkIG5vdCByZWFkIGVycm9yIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSB8fCAnJztcbiAgICAgICAgICAgIC8vIEhhbmRsZSBTU0Ugc3RyZWFtIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoJ3RleHQvZXZlbnQtc3RyZWFtJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+ToSBSZWNlaXZlZCBTU0Ugc3RyZWFtIHJlc3BvbnNlLCBwYXJzaW5nLi4uJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGFyc2VTU0VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgSlNPTiByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OoIFJlY2VpdmVkIEpTT04gcmVzcG9uc2U6Jywge1xuICAgICAgICAgICAgICAgIGhhc1Jlc3VsdDogISFkYXRhLnJlc3VsdCxcbiAgICAgICAgICAgICAgICBoYXNFcnJvcjogISFkYXRhLmVycm9yLFxuICAgICAgICAgICAgICAgIGlkOiBkYXRhLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEhUVFAgU3RyZWFtYWJsZSBNQ1AgcmVxdWVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIFN0cmVhbWFibGUgTUNQIHJlcXVlc3QgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgU2VydmVyLVNlbnQgRXZlbnRzIHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VTU0VSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keSBmb3IgU1NFIHN0cmVhbScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICBsZXQgbGFzdFJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7IC8vIEtlZXAgaW5jb21wbGV0ZSBsaW5lIGluIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3BvbnNlIHx8IHsganNvbnJwYzogJzIuMCcsIGlkOiAwLCBlcnJvcjogeyBjb2RlOiAtMSwgbWVzc2FnZTogJ05vIHJlc3BvbnNlIHJlY2VpdmVkJyB9IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkRhdGEuanNvbnJwYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzcG9uc2UgPSBqc29uRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIFNTRSBkYXRhOicsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXNwb25zZSB8fCB7IGpzb25ycGM6ICcyLjAnLCBpZDogMCwgZXJyb3I6IHsgY29kZTogLTEsIG1lc3NhZ2U6ICdObyB2YWxpZCByZXNwb25zZSByZWNlaXZlZCcgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG5leHQgcmVxdWVzdCBJRFxuICAgICAqL1xuICAgIGdldE5leHRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdElkKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzZXJ2ZXIgaXMgaGVhbHRoeSBhbmQgcmVzcG9uZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGhlYWx0aENoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5saXN0VG9vbHMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSFRUUCBTdHJlYW1hYmxlIE1DUCBoZWFsdGggY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEh0dHBTdHJlYW1hYmxlTUNQQ2xpZW50IH0gZnJvbSAnLi9IdHRwU3RyZWFtYWJsZU1DUENsaWVudCc7XG5leHBvcnQgY2xhc3MgTWljcm9zb2Z0RG9jc01DUENsaWVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyQ29uZmlnLCBhdXRoU2VydmljZSkge1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBuZXcgSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQoc2VydmVyQ29uZmlnLCBhdXRoU2VydmljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIE1DUCBjbGllbnQgYW5kIHBlcmZvcm0gaGFuZHNoYWtlIHdpdGggdGhlIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGF2YWlsYWJsZSB0b29scyBmcm9tIE1pY3Jvc29mdCBEb2NzIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9vbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQubGlzdFRvb2xzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYSB0b29sIG9uIHRoZSBNaWNyb3NvZnQgRG9jcyBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5jYWxsVG9vbCh0b29sTmFtZSwgYXJndW1lbnRzXyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHJlc291cmNlcyBmcm9tIE1pY3Jvc29mdCBEb2NzIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UmVzb3VyY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50Lmxpc3RSZXNvdXJjZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIHJlc291cmNlXG4gICAgICovXG4gICAgYXN5bmMgcmVhZFJlc291cmNlKHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LnJlYWRSZXNvdXJjZSh1cmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmVyIGlzIGhlYWx0aHkgYW5kIHJlc3BvbmRpbmdcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5oZWFsdGhDaGVjaygpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4855\n")}};