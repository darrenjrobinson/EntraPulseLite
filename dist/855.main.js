"use strict";exports.id=855,exports.ids=[855],exports.modules={4855:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MicrosoftDocsMCPClient: () => (/* binding */ MicrosoftDocsMCPClient)\n});\n\n;// ./src/mcp/clients/HttpStreamableMCPClient.ts\nclass HttpStreamableMCPClient {\n    constructor(serverConfig, authService) {\n        this.sessionId = null;\n        this.requestId = 1;\n        this.serverConfig = serverConfig;\n        this.authService = authService;\n        this.baseUrl = serverConfig.url || 'https://learn.microsoft.com/api/mcp';\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        try {\n            const initRequest = {\n                jsonrpc: '2.0',\n                id: this.getNextId(),\n                method: 'initialize',\n                params: {\n                    protocolVersion: '2024-11-05',\n                    capabilities: {\n                        tools: {},\n                        resources: {},\n                        sampling: {}\n                    },\n                    clientInfo: {\n                        name: 'EntraPulseLite',\n                        version: '1.0.1'\n                    }\n                }\n            };\n            console.log('üîå Initializing HTTP Streamable MCP client for:', this.baseUrl);\n            const response = await this.sendRequest(initRequest);\n            if (response.error) {\n                throw new Error(`Initialization failed: ${response.error.message}`);\n            }\n            console.log('‚úÖ HTTP Streamable MCP client initialized successfully');\n        }\n        catch (error) {\n            console.error('‚ùå Failed to initialize HTTP Streamable MCP client:', error);\n            throw error;\n        }\n    }\n    /**\n     * List available tools from the MCP server\n     */\n    async listTools() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list tools: ${response.error.message}`);\n        }\n        return response.result?.tools || [];\n    }\n    /**\n     * Call a tool on the MCP server\n     */\n    async callTool(toolName, arguments_) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/call',\n            params: {\n                name: toolName,\n                arguments: arguments_\n            }\n        };\n        console.log(`üîß HTTP Streamable MCP calling tool \"${toolName}\" with args:`, arguments_);\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Tool call failed: ${response.error.message}`);\n        }\n        console.log(`‚úÖ HTTP Streamable MCP tool \"${toolName}\" completed successfully`);\n        return response.result;\n    }\n    /**\n     * List available resources from the MCP server\n     */\n    async listResources() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list resources: ${response.error.message}`);\n        }\n        return response.result?.resources || [];\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/read',\n            params: {\n                uri\n            }\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to read resource: ${response.error.message}`);\n        }\n        return response.result;\n    }\n    /**\n     * Send HTTP Streamable request to the MCP server\n     */\n    async sendRequest(request) {\n        try {\n            const headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json, text/event-stream',\n                'User-Agent': 'MCP-Client/1.0.1'\n            };\n            // Add session ID if we have one\n            if (this.sessionId) {\n                headers['Mcp-Session-Id'] = this.sessionId;\n            }\n            // Add authentication headers if needed\n            if (this.serverConfig.authConfig?.type !== 'none') {\n                try {\n                    const authHeaders = await this.authService.getAuthHeaders('microsoft-docs');\n                    Object.assign(headers, authHeaders);\n                }\n                catch (authError) {\n                    console.warn('Failed to get auth headers for Microsoft Docs MCP:', authError);\n                    // Continue without auth headers as Microsoft Docs MCP may not require authentication\n                }\n            }\n            console.log('üåê Sending HTTP Streamable MCP request:', {\n                url: this.baseUrl,\n                method: request.method,\n                id: request.id,\n                hasSessionId: !!this.sessionId,\n                headers: Object.keys(headers),\n                bodyPreview: JSON.stringify(request).substring(0, 200)\n            });\n            const response = await fetch(this.baseUrl, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(request)\n            });\n            // Log response details for debugging\n            console.log('üì° Received response:', {\n                status: response.status,\n                statusText: response.statusText,\n                contentType: response.headers.get('Content-Type'),\n                hasSessionId: !!response.headers.get('Mcp-Session-Id')\n            });\n            // Check for session ID in response headers\n            const responseSessionId = response.headers.get('Mcp-Session-Id');\n            if (responseSessionId && !this.sessionId) {\n                this.sessionId = responseSessionId;\n                console.log('üìù Received session ID from server:', responseSessionId);\n            }\n            if (!response.ok) {\n                // For debugging 406 errors, try to get response body\n                let errorDetails = `HTTP ${response.status}: ${response.statusText}`;\n                try {\n                    const errorBody = await response.text();\n                    if (errorBody) {\n                        errorDetails += ` - Response: ${errorBody}`;\n                        console.log('‚ùå Error response body:', errorBody);\n                    }\n                }\n                catch (e) {\n                    console.log('‚ùå Could not read error response body');\n                }\n                throw new Error(errorDetails);\n            }\n            const contentType = response.headers.get('Content-Type') || '';\n            // Handle SSE stream response\n            if (contentType.includes('text/event-stream')) {\n                console.log('üì° Received SSE stream response, parsing...');\n                return await this.parseSSEResponse(response);\n            }\n            // Handle JSON response\n            const data = await response.json();\n            console.log('üì® Received JSON response:', {\n                hasResult: !!data.result,\n                hasError: !!data.error,\n                id: data.id\n            });\n            return data;\n        }\n        catch (error) {\n            console.error('‚ùå HTTP Streamable MCP request failed:', error);\n            throw new Error(`HTTP Streamable MCP request failed: ${error.message}`);\n        }\n    }\n    /**\n     * Parse Server-Sent Events response\n     */\n    async parseSSEResponse(response) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body for SSE stream');\n        }\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let lastResponse = null;\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || ''; // Keep incomplete line in buffer\n                for (const line of lines) {\n                    if (line.startsWith('data: ')) {\n                        const data = line.slice(6);\n                        if (data === '[DONE]') {\n                            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No response received' } };\n                        }\n                        try {\n                            const jsonData = JSON.parse(data);\n                            if (jsonData.jsonrpc) {\n                                lastResponse = jsonData;\n                            }\n                        }\n                        catch (parseError) {\n                            console.warn('Failed to parse SSE data:', data);\n                        }\n                    }\n                }\n            }\n            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No valid response received' } };\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     * Get next request ID\n     */\n    getNextId() {\n        return this.requestId++;\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        try {\n            await this.listTools();\n            return true;\n        }\n        catch (error) {\n            console.error('HTTP Streamable MCP health check failed:', error);\n            return false;\n        }\n    }\n}\n\n;// ./src/mcp/clients/MicrosoftDocsMCPClient.ts\n\nclass MicrosoftDocsMCPClient {\n    constructor(serverConfig, authService) {\n        this.httpClient = new HttpStreamableMCPClient(serverConfig, authService);\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        return this.httpClient.initialize();\n    }\n    /**\n     * List available tools from Microsoft Docs MCP server\n     */\n    async listTools() {\n        return this.httpClient.listTools();\n    }\n    /**\n     * Call a tool on the Microsoft Docs MCP server\n     */\n    async callTool(toolName, arguments_) {\n        return this.httpClient.callTool(toolName, arguments_);\n    }\n    /**\n     * List available resources from Microsoft Docs MCP server\n     */\n    async listResources() {\n        return this.httpClient.listResources();\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        return this.httpClient.readResource(uri);\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        return this.httpClient.healthCheck();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL3NyYy9tY3AvY2xpZW50cy9IdHRwU3RyZWFtYWJsZU1DUENsaWVudC50cz8wMDA5Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vc3JjL21jcC9jbGllbnRzL01pY3Jvc29mdERvY3NNQ1BDbGllbnQudHM/MDJlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckNvbmZpZywgYXV0aFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IDE7XG4gICAgICAgIHRoaXMuc2VydmVyQ29uZmlnID0gc2VydmVyQ29uZmlnO1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gYXV0aFNlcnZpY2U7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHNlcnZlckNvbmZpZy51cmwgfHwgJ2h0dHBzOi8vbGVhcm4ubWljcm9zb2Z0LmNvbS9hcGkvbWNwJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgTUNQIGNsaWVudCBhbmQgcGVyZm9ybSBoYW5kc2hha2Ugd2l0aCB0aGUgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2luaXRpYWxpemUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbFZlcnNpb246ICcyMDI0LTExLTA1JyxcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmc6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdFbnRyYVB1bHNlTGl0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIwgSW5pdGlhbGl6aW5nIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50IGZvcjonLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KGluaXRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5pdGlhbGl6YXRpb24gZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHRvb2xzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9vbHMoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAndG9vbHMvbGlzdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHRvb2xzOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdD8udG9vbHMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYSB0b29sIG9uIHRoZSBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0TmV4dElkKCksXG4gICAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzX1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBIVFRQIFN0cmVhbWFibGUgTUNQIGNhbGxpbmcgdG9vbCBcIiR7dG9vbE5hbWV9XCIgd2l0aCBhcmdzOmAsIGFyZ3VtZW50c18pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIGNhbGwgZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYOKchSBIVFRQIFN0cmVhbWFibGUgTUNQIHRvb2wgXCIke3Rvb2xOYW1lfVwiIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgcmVzb3VyY2VzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UmVzb3VyY2VzKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogdGhpcy5nZXROZXh0SWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3Jlc291cmNlcy9saXN0JyxcbiAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgcmVzb3VyY2VzOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdD8ucmVzb3VyY2VzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkUmVzb3VyY2UodXJpKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAncmVzb3VyY2VzL3JlYWQnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgdXJpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkIHJlc291cmNlOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBIVFRQIFN0cmVhbWFibGUgcmVxdWVzdCB0byB0aGUgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNQ1AtQ2xpZW50LzEuMC4xJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFkZCBzZXNzaW9uIElEIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydNY3AtU2Vzc2lvbi1JZCddID0gdGhpcy5zZXNzaW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXV0aGVudGljYXRpb24gaGVhZGVycyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlckNvbmZpZy5hdXRoQ29uZmlnPy50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IHRoaXMuYXV0aFNlcnZpY2UuZ2V0QXV0aEhlYWRlcnMoJ21pY3Jvc29mdC1kb2NzJyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYXV0aEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoYXV0aEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBhdXRoIGhlYWRlcnMgZm9yIE1pY3Jvc29mdCBEb2NzIE1DUDonLCBhdXRoRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRob3V0IGF1dGggaGVhZGVycyBhcyBNaWNyb3NvZnQgRG9jcyBNQ1AgbWF5IG5vdCByZXF1aXJlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfjJAgU2VuZGluZyBIVFRQIFN0cmVhbWFibGUgTUNQIHJlcXVlc3Q6Jywge1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5iYXNlVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgICAgICAgICAgaGFzU2Vzc2lvbklkOiAhIXRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5rZXlzKGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIGJvZHlQcmV2aWV3OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KS5zdWJzdHJpbmcoMCwgMjAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuYmFzZVVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTG9nIHJlc3BvbnNlIGRldGFpbHMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6EgUmVjZWl2ZWQgcmVzcG9uc2U6Jywge1xuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSxcbiAgICAgICAgICAgICAgICBoYXNTZXNzaW9uSWQ6ICEhcmVzcG9uc2UuaGVhZGVycy5nZXQoJ01jcC1TZXNzaW9uLUlkJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHNlc3Npb24gSUQgaW4gcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VTZXNzaW9uSWQgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnTWNwLVNlc3Npb24tSWQnKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVNlc3Npb25JZCAmJiAhdGhpcy5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHJlc3BvbnNlU2Vzc2lvbklkO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFJlY2VpdmVkIHNlc3Npb24gSUQgZnJvbSBzZXJ2ZXI6JywgcmVzcG9uc2VTZXNzaW9uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIC8vIEZvciBkZWJ1Z2dpbmcgNDA2IGVycm9ycywgdHJ5IHRvIGdldCByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yRGV0YWlscyA9IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckRldGFpbHMgKz0gYCAtIFJlc3BvbnNlOiAke2Vycm9yQm9keX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KdjCBFcnJvciByZXNwb25zZSBib2R5OicsIGVycm9yQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KdjCBDb3VsZCBub3QgcmVhZCBlcnJvciByZXNwb25zZSBib2R5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgfHwgJyc7XG4gICAgICAgICAgICAvLyBIYW5kbGUgU1NFIHN0cmVhbSByZXNwb25zZVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKCd0ZXh0L2V2ZW50LXN0cmVhbScpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6EgUmVjZWl2ZWQgU1NFIHN0cmVhbSByZXNwb25zZSwgcGFyc2luZy4uLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhcnNlU1NFUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIEpTT04gcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TqCBSZWNlaXZlZCBKU09OIHJlc3BvbnNlOicsIHtcbiAgICAgICAgICAgICAgICBoYXNSZXN1bHQ6ICEhZGF0YS5yZXN1bHQsXG4gICAgICAgICAgICAgICAgaGFzRXJyb3I6ICEhZGF0YS5lcnJvcixcbiAgICAgICAgICAgICAgICBpZDogZGF0YS5pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBIVFRQIFN0cmVhbWFibGUgTUNQIHJlcXVlc3QgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBTdHJlYW1hYmxlIE1DUCByZXF1ZXN0IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIFNlcnZlci1TZW50IEV2ZW50cyByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlU1NFUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHkgZm9yIFNTRSBzdHJlYW0nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgbGV0IGxhc3RSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGxpbmVzLnBvcCgpIHx8ICcnOyAvLyBLZWVwIGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICdbRE9ORV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXNwb25zZSB8fCB7IGpzb25ycGM6ICcyLjAnLCBpZDogMCwgZXJyb3I6IHsgY29kZTogLTEsIG1lc3NhZ2U6ICdObyByZXNwb25zZSByZWNlaXZlZCcgfSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25EYXRhLmpzb25ycGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3BvbnNlID0ganNvbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBTU0UgZGF0YTonLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzcG9uc2UgfHwgeyBqc29ucnBjOiAnMi4wJywgaWQ6IDAsIGVycm9yOiB7IGNvZGU6IC0xLCBtZXNzYWdlOiAnTm8gdmFsaWQgcmVzcG9uc2UgcmVjZWl2ZWQnIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBuZXh0IHJlcXVlc3QgSURcbiAgICAgKi9cbiAgICBnZXROZXh0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RJZCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmVyIGlzIGhlYWx0aHkgYW5kIHJlc3BvbmRpbmdcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubGlzdFRvb2xzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hUVFAgU3RyZWFtYWJsZSBNQ1AgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBIdHRwU3RyZWFtYWJsZU1DUENsaWVudCB9IGZyb20gJy4vSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQnO1xuZXhwb3J0IGNsYXNzIE1pY3Jvc29mdERvY3NNQ1BDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckNvbmZpZywgYXV0aFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gbmV3IEh0dHBTdHJlYW1hYmxlTUNQQ2xpZW50KHNlcnZlckNvbmZpZywgYXV0aFNlcnZpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBNQ1AgY2xpZW50IGFuZCBwZXJmb3JtIGhhbmRzaGFrZSB3aXRoIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgdG9vbHMgZnJvbSBNaWNyb3NvZnQgRG9jcyBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRvb2xzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50Lmxpc3RUb29scygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgdG9vbCBvbiB0aGUgTWljcm9zb2Z0IERvY3MgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxUb29sKHRvb2xOYW1lLCBhcmd1bWVudHNfKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGF2YWlsYWJsZSByZXNvdXJjZXMgZnJvbSBNaWNyb3NvZnQgRG9jcyBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFJlc291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5saXN0UmVzb3VyY2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGVudHMgb2YgYSBzcGVjaWZpYyByZXNvdXJjZVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRSZXNvdXJjZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5yZWFkUmVzb3VyY2UodXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5IGFuZCByZXNwb25kaW5nXG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuaGVhbHRoQ2hlY2soKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4855\n")}};